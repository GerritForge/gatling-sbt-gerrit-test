package gerritforge

import com.github.barbasa.gatling.git.GatlingGitConfiguration
import com.github.barbasa.gatling.git.protocol.GitProtocol
import gerritforge.GerritRealLifeSimulation._
import gerritforge.SimulationUtil.httpProtocol
import gerritforge.config.SimulationConfig.simulationConfig
import gerritforge.scenarios.git.backend.Gerrit
import gerritforge.scenarios.git.{CloneCommand, CreateChangeCommand}
import gerritforge.scenarios.rest.changes.{AbandonThenRestoreChange, PostComment, SubmitChange}
import io.gatling.core.Predef._
import io.gatling.core.controller.inject.closed.ClosedInjectionStep
import io.gatling.core.structure.ScenarioBuilder

import scala.concurrent.duration.FiniteDuration

// This simulation is based on the traffic extracted from the cue-lang project logs.
// By analyzing the logs we defined and reproduced the traffic shape (command
// types and their frequency) over a day.
class GerritRealLifeSimulation extends Simulation {

  def getScenarioProfile(duration: FiniteDuration): Seq[ClosedInjectionStep] = {
    Seq(
      constantConcurrentUsers(simulationConfig.numUsers / 2) during duration / 3,
      rampConcurrentUsers(simulationConfig.numUsers)
        .to(simulationConfig.numUsers) during duration / 3,
      constantConcurrentUsers(simulationConfig.numUsers / 2) during duration / 3
    )
  }

  setUp(
    httpCloneScenario
      .inject(
        getScenarioProfile(httpCloneDuration)
      )
      .protocols(GitProtocol),
    submitScenario
      .inject(
        getScenarioProfile(submitDuration)
      )
      .protocols(httpProtocol),
    createChangeCommandScenario
      .inject(
        getScenarioProfile(abandonDuration + postCommentDuration)
      )
      .protocols(httpProtocol)
      .andThen(
        abandonScenario
          .inject(
            getScenarioProfile(abandonDuration)
          )
          .protocols(httpProtocol),
        postCommentScenario
          .inject(
            getScenarioProfile(postCommentDuration)
          )
          .protocols(httpProtocol)
      )
  ).maxDuration(simulationConfig.duration)
}

object GerritRealLifeSimulation {
  implicit val gitConfig: GatlingGitConfiguration = GatlingGitConfiguration()
  private val httpUrl: String                     = simulationConfig.httpUrl.get

  private val postCommentScenario: ScenarioBuilder = PostComment().scn
  private val httpCloneScenario = new CloneCommand(
    Gerrit,
    httpUrl
  ).scn
  private val submitScenario: ScenarioBuilder  = SubmitChange.scn
  private val abandonScenario: ScenarioBuilder = AbandonThenRestoreChange.scn
  private val createChangeCommandScenario =
    new CreateChangeCommand(
      simulationConfig.gitBackend,
      httpUrl,
      Seq("AbandonThenRestoreChange", "PostComment")
    ).scn

  // Define the distribution of the traffic generated by each scenario in the simulation by assigning
  // a percentage of the whole simulation duration
  private val scenariosPct = Map(
    httpCloneScenario   -> simulationConfig.cloneScnPct,
    postCommentScenario -> simulationConfig.postCommentScnPct,
    submitScenario      -> simulationConfig.submitScnPct,
    abandonScenario     -> simulationConfig.abandonScnPct
  )

  private val httpCloneDuration   = simulationConfig.duration * scenariosPct(httpCloneScenario) / 100
  private val postCommentDuration = simulationConfig.duration * scenariosPct(postCommentScenario) / 100
  private val submitDuration      = simulationConfig.duration * scenariosPct(submitScenario) / 100
  private val abandonDuration     = simulationConfig.duration * scenariosPct(abandonScenario) / 100
}
